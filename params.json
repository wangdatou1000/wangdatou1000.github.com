{"name":"Wangdatou1000.GitHub.com","tagline":"","body":"# wangdatou1000.github.io\r\n##个人博测试\r\n#[字符串匹配的sunday算法](http://news.163.com)\r\n``` java\r\npackage string;\r\n/**\r\n * 功能描述：sunday字符串匹配算法，java实现。 1,Sunday算法是Daniel\r\n * M.Sunday于1990年提出的一种比BM算法搜索速度更快的算法。\r\n * \r\n * 2,Sunday算法其实思想跟BM算法很相似，只不过Sunday算法是从前往后匹配， 在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。\r\n * 如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+ 1；否则，同BM算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。\r\n * \r\n * @author 王世杰\r\n * @version 1.0, 2015年4月22日 下午2:38:26\r\n */\r\npublic class SundayForSubString {\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n\r\n\tpublic int indexOf(String text, String pattern) {\r\n\t\tif (text == null || pattern == null)\r\n\t\t\treturn -1;\r\n\t\tfinal int n = text.length();\r\n\t\tfinal int m = pattern.length();\r\n\t\tif (m > n || m == 0)\r\n\t\t\treturn -1;\r\n\t\tint i = 0, j = 0;\r\n\t\tint ti = 0, tj = 0;\r\n\t\tfinal char[] t = text.toCharArray();\r\n\t\tfinal char[] p = pattern.toCharArray();\r\n\t\twhile (i < n && j < m) {\r\n\t\t\t/* 先左对齐往右挨个比较，如果相同则比较下一个。 */\r\n\t\t\tif (t[i] == p[j]) {\r\n\t\t\t\ti++;\r\n\t\t\t\tj++;\r\n\t\t\t} else {\r\n\t\t\t\t/*\r\n\t\t\t\t * 等出现不相同字符时，则将长字符串相对短标字符串尾部下一个字符与短标字符串比较， 比较顺序是从短标字符末尾开始往头逆序比较。\r\n\t\t\t\t */\r\n\t\t\t\tti = i + m - j;// 尾部的下一个字符为比较字符\r\n\t\t\t\ttj = m - 1;// 从尾部开始\r\n\t\t\t\tif (ti >= n)\r\n\t\t\t\t\tbreak;// 如果比较字符不存在，则结束比较。\r\n\t\t\t\tfor (; tj >= 0 && t[ti] != p[tj]; tj--)\r\n\t\t\t\t\t;// 如果不相同就一直比较，直到相同为止。\r\n\t\t\t\ti = i - j + m - tj;// 设置字符串移动后的的位置，也就是j相对长的位置，\r\n\t\t\t\tj = 0;// 从短字符串头部开始比较\r\n\t\t\t}\r\n\t\t\t// 进行新一轮的比较\r\n\t\t}\r\n\t\t// 比较结束后，看j与m是否相等，相等则比较完成找到了字符串，并返回短字符串在长字符串中的起始位置，\r\n\t\t// 如果不相等则没有匹配到，返回-1。\r\n\t\treturn j == m ? (i - j) : -1;\r\n\t}\r\n\r\n}\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}